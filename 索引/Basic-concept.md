# 什么是索引？
索引的定义就是帮助存储引擎快速找到数据的一种数据结构，也可以说是数据的目录。  

# 索引的分类
## 按数据结构分类
从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。  
<img width="811" height="421" alt="image" src="https://github.com/user-attachments/assets/75f9993a-5f62-4327-bda9-9abb182aa0fc" />  
InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。  
在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：  
如果有主键，默认会使用主键作为聚簇索引的索引键（key）；  
如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；  
在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；  
其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的是 B+Tree 索引。  

B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。  
<img width="1231" height="499" alt="image" src="https://github.com/user-attachments/assets/c520a22f-3b7f-4956-84ed-c7e9a070ebf3" />  

主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：  
主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；  
二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。  
<img width="1231" height="499" alt="image" src="https://github.com/user-attachments/assets/562b60d7-0299-4fc9-a1d7-3e3fd1ec6772" />  
如果我用二级索引查询，会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。  
<img width="2581" height="702" alt="image" src="https://github.com/user-attachments/assets/75d75c0d-b78d-4b6d-a834-bcf643d2a216" />  
不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：  
select id from product where product_no = '0002';  
这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。  

## 按物理存储分类  
从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。  
主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；  
二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。  

## 按字段特性分类
从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。  

### 主键索引
主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。  

### 唯一索引
唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。  

### 普通索引
普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。  

### 前缀索引
前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。  
使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。  

## 按字段个数分类
从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。  
建立在单列上的索引称为单列索引，比如主键索引；  
建立在多列上的索引称为联合索引。  

### 联合索引
通过将多个字段组合成一个索引，该索引就被称为联合索引。  
<img width="1141" height="571" alt="image" src="https://github.com/user-attachments/assets/3a9f743e-ad17-41f8-b387-fb45ad235ee6" />  
可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。  
因此，使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。  
联合索引范围查询：联合索引有一些特殊情况，并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。  
这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。  
范围查询有很多种，那到底是哪些范围查询会导致联合索引的最左匹配原则会停止匹配呢？  
Q1: select * from t_table where a > 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？  
由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。  
但是在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的。比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 a 字段的值都符合 a > 1 查询条件，而 b 字段的值是无序的：因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。  

### 索引下推
现在我们知道，对于联合索引（a, b），在执行 select * from table where a > 1 and b = 2语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？  
在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。  
而 MySQL 5.6 引入的索引下推优化（index condition pushdown)，可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。  

### 索引区分度
实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。  
区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：

<img width="922" height="282" alt="image" src="https://github.com/user-attachments/assets/2d07a6e2-4acf-49f1-b7ca-d71f51dc6219" />  

# 什么时候需要索引？什么时候不需要？
## 什么时候需要索引？
字段有唯一性限制的，比如商品编码；  
经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。  
经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。  

## 什么时候不需要索引？
WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。  
字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。  
表数据太少的时候，不需要创建索引；  
经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。  






