# 索引的优化

## 前缀索引优化
前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，前缀索引可以减少索引字段大小，从而增加一个索引页中存储的索引值，有效提高索引的查询速度。  
在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。  
不过，前缀索引有一定的局限性，例如：  
order by 就无法使用前缀索引；  
无法把前缀索引用作覆盖索引。  

## 覆盖索引优化
覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。  
假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？  
我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。  
所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的I/O操作。  

## 主键索引最好是自增的  
InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。  
如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。  
如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。  
另外，主键字段的长度不要太大，因为主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小。  

## 索引最好设置为NOT NULL
为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：  
第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。  
第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中至少会用 1 字节空间存储 NULL 值列表。  

## 防止索引失效
