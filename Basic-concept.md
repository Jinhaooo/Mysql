# 执行一条Selcet语句后发生了什么
## MySQL的整体架构
<img width="1261" height="721" alt="image" src="https://github.com/user-attachments/assets/709866be-0470-4a46-9c6a-6b0da5292229" />  
MySQL的架构分为两层，Server层和存储引擎层。  
Server层负责建立连接，分析和执行SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。  

存储引擎层主要负责数据的存取和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始，InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。  

## 第一步：连接器
首先我们要建立MySQL连接，MySQL是基于TCP协议传输的，所以需要先经过三次握手。  
如果完成TCP连接的建立，连接器会验证用户名和密码，如果没有问题，连接器就会保存用户的权限，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。  
所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。  
MySQL同样支持长连接，但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。  
如何解决长连接占用内存过多的问题呢？一般有两种办法：1.定期断开长连接。 2.客户端主动重置连接。  

## 第二步：查询缓存
连接器完成工作后，Server层会解析SQL语句的第一个字段，如果是SELECT语句，MySQL就会去查询缓存。  
但是，对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。所以在MySQL8.0后，查询缓存这个功能就被删掉了。  

## 第三步：解析SQL
在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。  
### 解析器
首先，解析器会进行词法分析，MySQL 会根据你输入的字符串识别出关键字出来。  
<img width="738" height="172" alt="image" src="https://github.com/user-attachments/assets/f04eb299-922e-463c-b92c-330dfaa6b62a" />  
然后会进行语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。  
<img width="1572" height="800" alt="image" src="https://github.com/user-attachments/assets/2d14c2c2-ad33-41bf-a228-01c09dbaf870" />  
如果输入的SQL语法不对，解析器就会报错。  

## 第四步：执行SQL
经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条SELECT 查询语句流程主要可以分为下面这三个阶段：  
每条SELECT 查询语句流程主要可以分为下面这三个阶段：  
optimize 阶段，也就是优化阶段；  
execute 阶段，也就是执行阶段；  
### 预处理器
预处理器会检查 SQL 查询语句中的表或者字段是否存在；然后将 select * 中的 * 符号，扩展为表上的所有列。  
### 优化器
优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。  
### 执行器
经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。

总结：  
执行一条 SQL 查询语句，期间发生了什么？  
连接器： 建立连接，管理连接，校验用户身份。  
查询缓存： 查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；  
解析SQL：通过解析器对SQL语句进行词法分析和语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
执行SQL：  
预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。  
优化阶段： 基于查询成本，确定执行查询的方案。  
执行器： 根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端  

# MySQL 一行记录是怎么存储的？
## MySQL的数据存在哪个文件？
MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎。所以，本文主要以 InnoDB 存储引擎展开讨论。  
我们每创建一个 database（数据库）都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。  
比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。  
然后，我们进入 /var/lib/mysql/my_test 目录，共有三个文件，这三个文件分别代表着：  
db.opt，用来存储当前数据库的默认字符集和字符校验规则。  
t_order.frm ，t_order 的表结构会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。  
t_order.ibd，t_order 的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。  
现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。  

## 表空间文件的结构
表空间由段(Segment),区(extent),页(page)，行(row)组成，InnoDB存储引擎结构如下图所示：  
<img width="686" height="651" alt="image" src="https://github.com/user-attachments/assets/fb400d09-a359-4431-9efa-4b3eda407cf6" />  
1.行  
数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。  

2.页  
记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。  
因此，InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。  
默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。  

3.区  
我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。  
在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。  

4.段  
表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。  
索引段：存放 B + 树的非叶子节点的区的集合；  
数据段：存放 B + 树的叶子节点的区的集合；  
回滚段：存放的是回滚数据的区的集合。  









