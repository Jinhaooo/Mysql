# 执行一条Selcet语句后发生了什么
## MySQL的整体架构
<img width="1261" height="721" alt="image" src="https://github.com/user-attachments/assets/709866be-0470-4a46-9c6a-6b0da5292229" />  
MySQL的架构分为两层，Server层和存储引擎层。  
Server层负责建立连接，分析和执行SQL。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。  

存储引擎层主要负责数据的存取和提取。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始，InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。  

## 第一步：连接器
首先我们要建立MySQL连接，MySQL是基于TCP协议传输的，所以需要先经过三次握手。  
如果完成TCP连接的建立，连接器会验证用户名和密码，如果没有问题，连接器就会保存用户的权限，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。  
所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。  
MySQL同样支持长连接，但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。  
如何解决长连接占用内存过多的问题呢？一般有两种办法：1.定期断开长连接。 2.客户端主动重置连接。  

## 第二步：查询缓存
连接器完成工作后，Server层会解析SQL语句的第一个字段，如果是SELECT语句，MySQL就会去查询缓存。  
但是，对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。所以在MySQL8.0后，查询缓存这个功能就被删掉了。  

## 第三步：解析SQL
在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。  
### 解析器
首先，解析器会进行词法分析，MySQL 会根据你输入的字符串识别出关键字出来。  
<img width="738" height="172" alt="image" src="https://github.com/user-attachments/assets/f04eb299-922e-463c-b92c-330dfaa6b62a" />  
然后会进行语法分析。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。  
<img width="1572" height="800" alt="image" src="https://github.com/user-attachments/assets/2d14c2c2-ad33-41bf-a228-01c09dbaf870" />  
如果输入的SQL语法不对，解析器就会报错。  

## 第四步：执行SQL
经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条SELECT 查询语句流程主要可以分为下面这三个阶段：  
每条SELECT 查询语句流程主要可以分为下面这三个阶段：  
optimize 阶段，也就是优化阶段；  
execute 阶段，也就是执行阶段；  
### 预处理器
预处理器会检查 SQL 查询语句中的表或者字段是否存在；然后将 select * 中的 * 符号，扩展为表上的所有列。  
### 优化器
优化器主要负责将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。  
### 执行器
经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。

总结：  
执行一条 SQL 查询语句，期间发生了什么？  
连接器： 建立连接，管理连接，校验用户身份。  
查询缓存： 查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；  
解析SQL：通过解析器对SQL语句进行词法分析和语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
执行SQL：  
预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。  
优化阶段： 基于查询成本，确定执行查询的方案。  
执行器： 根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端  

# MySQL 一行记录是怎么存储的？
## MySQL的数据存在哪个文件？
MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎。所以，本文主要以 InnoDB 存储引擎展开讨论。  
我们每创建一个 database（数据库）都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。  
比如，我这里有一个名为 my_test 的 database，该 database 里有一张名为 t_order 数据库表。  
然后，我们进入 /var/lib/mysql/my_test 目录，共有三个文件，这三个文件分别代表着：  
db.opt，用来存储当前数据库的默认字符集和字符校验规则。  
t_order.frm ，t_order 的表结构会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。  
t_order.ibd，t_order 的表数据会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。  
现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。  

## 表空间文件的结构
表空间由段(Segment),区(extent),页(page)，行(row)组成，InnoDB存储引擎结构如下图所示：  
<img width="686" height="651" alt="image" src="https://github.com/user-attachments/assets/fb400d09-a359-4431-9efa-4b3eda407cf6" />  
1.行  
数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。  

2.页  
记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。  
因此，InnoDB 的数据是按「页」为单位来读写的，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。  
默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。  

3.区  
我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。  
在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。  

4.段  
表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。  
索引段：存放 B + 树的非叶子节点的区的集合；  
数据段：存放 B + 树的叶子节点的区的集合；  
回滚段：存放的是回滚数据的区的集合。  

## InnoDB行格式
行格式（row_format），就是一条记录的存储结构。  
InnoDB 提供了 4 种行格式，分别是Redundant、Compact、Dynamic和 Compressed 行格式。  
Redundant 是很古老的行格式了，MySQL 5.0 版本之前用的行格式，现在基本没人用了。  
MySQL5.0之后引入了Compact这么一种紧凑的行格式，Dynamic和Compressed是基于Compact优化的，同样紧凑的行格式，在MySQL5.7之后，默认使用Dynamic格式.

## Compact格式
<img width="2336" height="562" alt="image" src="https://github.com/user-attachments/assets/dbd96443-82d0-4d1e-b501-352481055308" />  
### 记录的额外信息  
1.变长字段长度列表  
char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面。  
为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：  
现在 t_user 表里有这三条记录：  
<img width="550" height="190" alt="image" src="https://github.com/user-attachments/assets/a818fc3b-3b36-4ac7-8051-4d6143d90d80" />  
接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。  
<img width="2234" height="598" alt="image" src="https://github.com/user-attachments/assets/77219a70-5e4f-469a-a3ba-9d9787092ae3" />  
name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；  
phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；  
age 列和 id 列不是变长字段，所以这里不用管。  
这些变长字段的真实数据占用的字节数会按照列的顺序逆序存放。  
同理得到第二条记录：  
<img width="2204" height="578" alt="image" src="https://github.com/user-attachments/assets/09806607-79cd-47b3-b55b-9fd3076e9b8b" />  
第三条记录中 phone 列的值是 NULL，NULL 是不会存放在行格式中记录的真实数据部分里的，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。  
<img width="2232" height="596" alt="image" src="https://github.com/user-attachments/assets/f8c14706-ae2c-40cf-a51f-bfdcb960b26e" />  

为什么「变长字段长度列表」的信息要按照逆序存放？  
主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。  
「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率。  
同理，null值列表也要逆序排放。

变长字段长度列表不是必须的，当数据中没有变长字段时，就不会有这个列表了。  

2.Null值列表  
表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。  
如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。 
二进制位的值为1时，代表该列的值为NULL。二进制位的值为0时，代表该列的值不为NULL。  
<img width="1020" height="582" alt="image" src="https://github.com/user-attachments/assets/a55ce39d-c7a5-463a-aa7f-d527a2056d5b" />  
 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，不足八位需要在高位补零。  

 NULL值列表也不是固定的，当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了。所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。  

 3.记录头信息  
 记录头信息中包含的内容很多，这里说几个比较重要的：  
 delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。  
 next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。  
 record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。  

 ### 记录的真实数据
 <img width="1336" height="288" alt="image" src="https://github.com/user-attachments/assets/7fef29ac-95b5-40a3-80f4-14646438719f" />  
 记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer。  
 row_id:如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。  
 trx_id:事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。  
 roll_pointer:这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。

 ## 行溢出时，MySQL是怎么处理的
 一个页的大小一般是 16KB，也就是 16384字节，而一个 varchar(n) 类型的列最多可以存储 65532字节，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会发生行溢出，多的数据就会存到另外的「溢出页」中。  
 如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。  
Compact行格式处理的方式是：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。  
<img width="1400" height="508" alt="image" src="https://github.com/user-attachments/assets/c255ae33-cfb8-4e28-b098-e0ccfdb57c1e" />  
Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：  
<img width="1230" height="470" alt="image" src="https://github.com/user-attachments/assets/0046f421-6041-45cc-bb54-a7927b9c627f" />  

需要理解的是，按照表空间结构来看，行应该是比页要小的单位。但是实际上，页是MySQLI/O和缓存执行的最小单位，而行是逻辑数据的基本单位，如果严格限制每行必须完整放入一页 → 会严重限制列的大小和灵活性，如果允许行跨页存储 → 增加了复杂度，但提供了更大的灵活性。这是一种牺牲性能换取灵活性的权衡。



 













